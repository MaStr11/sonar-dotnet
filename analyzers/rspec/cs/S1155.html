<h2>Why is this an issue?</h2>
<p>When you call <code>Any()</code>, it clearly communicates the codeâ€™s intention, which is to check if the collection is empty. Using <code>Count()
== 0</code> for this purpose is less direct and makes the code slightly more complex. However, there are some cases where special attention should be
paid:</p>
<ul>
  <li> if the collection is an <code>EntityFramework</code> or other ORM query, calling <code>Count()</code> will cause executing a potentially
  massive SQL query and could put a large overhead on the application database. Calling <code>Any()</code> will also connect to the database, but will
  generate much more efficient SQL. </li>
  <li> if the collection is part of a LINQ query that contains <code>Select()</code> statements that create objects, a large amount of memory could be
  unnecessarily allocated. Calling <code>Any()</code> will be much more efficient because it will execute fewer iterations of the enumerable. </li>
</ul>
<h2>How to fix it</h2>
<p>Prefer using <code>Any()</code> to test for emptiness over <code>Count()</code>.</p>
<h3>Code examples</h3>
<h4>Noncompliant code example</h4>
<pre data-diff-id="1" data-diff-type="noncompliant">
private static bool HasContent(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() &gt; 0;  // Noncompliant
}

private static bool HasContent2(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() &gt;= 1;  // Noncompliant
}

private static bool IsEmpty(IEnumerable&lt;string&gt; strings)
{
  return strings.Count() == 0;  // Noncompliant
}
</pre>
<h4>Compliant solution</h4>
<pre data-diff-id="1" data-diff-type="compliant">
private static bool HasContent(IEnumerable&lt;string&gt; strings)
{
  return strings.Any();
}

private static bool HasContent2(IEnumerable&lt;string&gt; strings)
{
  return strings.Any();
}

private static bool IsEmpty(IEnumerable&lt;string&gt; strings)
{
  return !strings.Any();
}
</pre>
<h2>Resources</h2>
<h3>Benchmarks</h3>
<table>
  <colgroup>
    <col style="width: 25%;">
    <col style="width: 25%;">
    <col style="width: 25%;">
    <col style="width: 25%;">
  </colgroup>
  <thead>
    <tr>
      <th>Method</th>
      <th>Runtime</th>
      <th>Mean</th>
      <th>Standard Deviation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><p>Count</p></td>
      <td><p>.NET 9.0</p></td>
      <td><p>2,841.003 ns</p></td>
      <td><p>266.0238 ns</p></td>
    </tr>
    <tr>
      <td><p>Any</p></td>
      <td><p>.NET 9.0</p></td>
      <td><p>1.749 ns</p></td>
      <td><p>0.1242 ns</p></td>
    </tr>
    <tr>
      <td><p>Count</p></td>
      <td><p>.NET Framework 4.8.1</p></td>
      <td><p>71,125.275 ns</p></td>
      <td><p>731.0382 ns</p></td>
    </tr>
    <tr>
      <td><p>Any</p></td>
      <td><p>.NET Framework 4.8.1</p></td>
      <td><p>31.774 ns</p></td>
      <td><p>0.3196 ns</p></td>
    </tr>
  </tbody>
</table>
<h4>Glossary</h4>
<ul>
  <li> <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">Mean</a> </li>
  <li> <a href="https://en.wikipedia.org/wiki/Standard_deviation">Standard Deviation</a> </li>
</ul>
<p>The results were generated by running the following snippet with <a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet</a>:</p>
<pre>
private IEnumerable&lt;int&gt; collection;

public const int N = 10_000;

[GlobalSetup]
public void GlobalSetup()
{
    collection = Enumerable.Range(0, N).Select(x =&gt; N - x);
}

[Benchmark(Baseline = true)]
public bool Count() =&gt;
    collection.Count() &gt; 0;

[Benchmark]
public bool Any() =&gt;
    collection.Any();
</pre>
<p>Hardware Configuration:</p>
<pre>
BenchmarkDotNet v0.14.0, Windows 10 (10.0.19045.5247/22H2/2022Update)
12th Gen Intel Core i7-12800H, 1 CPU, 20 logical and 14 physical cores
  [Host]               : .NET Framework 4.8.1 (4.8.9282.0), X64 RyuJIT VectorSize=256
  .NET 9.0             : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2
  .NET Framework 4.8.1 : .NET Framework 4.8.1 (4.8.9282.0), X64 RyuJIT VectorSize=256
</pre>

